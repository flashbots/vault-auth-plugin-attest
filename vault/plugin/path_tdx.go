package plugin

import (
	"context"
	"fmt"

	"github.com/hashicorp/vault/sdk/framework"
	"github.com/hashicorp/vault/sdk/helper/tokenutil"
	"github.com/hashicorp/vault/sdk/logical"
)

const helpTDXSynopsys = `
Manage TDX trusted domains that are allowed to authenticate.
`

const helpTDXDescription = `
This endpoint allows you to create, read, update, and delete TDX trusted
domains that are allowed to authenticate.
`

const (
	opPrefixTDX = "tdx-op-prefix"
)

func pathTDX(b *backend) *framework.Path {
	path := &framework.Path{
		Pattern:         "tdx/" + framework.GenericNameRegex("name"),
		HelpSynopsis:    helpTDXSynopsys,
		HelpDescription: helpTDXDescription,

		ExistenceCheck: b.pathTDXExists,

		Fields: map[string]*framework.FieldSchema{
			"name": {
				Type:        framework.TypeString,
				Description: "TDX trusted domain name",
			},

			// TOTP

			"totp_secret": {
				Type:        framework.TypeString,
				Description: "Secret used to generate TOTP codes",

				DisplayAttrs: &framework.DisplayAttributes{
					Name:        "TOTP secret",
					Description: "Secret used to generate TOTP codes (can only be set, and is never shown in the UI)",
					Sensitive:   true,
				},
			},

			// MROWNER

			"tdx_mr_owner": {
				Type:        framework.TypeString,
				Description: "Expected software-defined ID for the TD's owner",

				DisplayAttrs: &framework.DisplayAttributes{
					Name:        "MROWNER",
					Description: "Software-defined ID for the TD's owner (base64-encoded 48 byte array)",
				},
			},

			// MROWNERCONFIG

			"tdx_mr_owner_config": {
				Type:        framework.TypeString,
				Description: "Expected software-defined ID for owner-defined configuration of the TD",

				DisplayAttrs: &framework.DisplayAttributes{
					Name:        "MROWNERCONFIG",
					Description: "Software-defined ID for owner-defined configuration of the TD, e.g., specific to the workload rather than the runtime or OS (base64-encoded 48 byte array)",
				},
			},

			// MRCONFIGID

			"tdx_mr_config_id": {
				Type:        framework.TypeString,
				Description: "Expected software-defined ID for non-owner-defined configuration of the TD",

				DisplayAttrs: &framework.DisplayAttributes{
					Name:        "MRCONFIGID",
					Description: "Software-defined ID for non-owner-defined configuration of the TD, e.g., runtime or OS configuration (base64-encoded 48 byte array)",
				},
			},

			// MRTD

			"tdx_mr_td": {
				Type:        framework.TypeString,
				Description: "Expected measurement of initial contents of the TD",

				DisplayAttrs: &framework.DisplayAttributes{
					Name:        "MRTD",
					Description: "Measurement of the initial contents of the TD (base64-encoded SHA384)",
				},
			},

			// RTMR0

			"tdx_rtmr0": {
				Type:        framework.TypeString,
				Description: "Expected runtime-extendable measurement register #0",

				DisplayAttrs: &framework.DisplayAttributes{
					Name:        "RTMR[0]",
					Description: "Runtime extendable measurement register #0 (base64-encoded SHA384). By convention, RTMR[0] is updated by the TD virtual firmware/BIOS",
				},
			},

			// RTMR1

			"tdx_rtmr1": {
				Type:        framework.TypeString,
				Description: "Expected runtime-extendable measurement register #1",

				DisplayAttrs: &framework.DisplayAttributes{
					Name:        "RTMR[1]",
					Description: "Runtime extendable measurement register #1 (base64-encoded SHA384). By convention, RTMR[1] is updated by the TD virtual firmware/BIOS",
				},
			},

			// RTMR2

			"tdx_rtmr2": {
				Type:        framework.TypeString,
				Description: "Expected runtime-extendable measurement register #2",

				DisplayAttrs: &framework.DisplayAttributes{
					Name:        "RTMR[2]",
					Description: "Runtime extendable measurement register #2 (base64-encoded SHA384). By convention, RTMR[2] measurements are generated by the OS",
				},
			},

			// RTMR3

			"tdx_rtmr3": {
				Type:        framework.TypeString,
				Description: "Expected runtime-extendable measurement register #3",

				DisplayAttrs: &framework.DisplayAttributes{
					Name:        "RTMR[3]",
					Description: "Runtime extendable measurement register #3 (base64-encoded SHA384). By convention, RTMR[3] measurements are generated by runtime code",
				},
			},

			// TDATTIBUTES.TUD

			"tdx_check_debug": {
				Type:        framework.TypeBool,
				Description: "Verify that TUD.DEBUG attribute is unset",
				Default:     true,

				DisplayAttrs: &framework.DisplayAttributes{
					Name:        "Check TDATTIBUTES.TUD",
					Description: "Verify that TD Under Debug flag is set to zero (if it's not zero then TD should not be trusted and thus should not be provisioned with production secrets)",
				},
			},

			// SEC.SEPT_VE_DISABLE

			"tdx_check_sept_ve_disable": {
				Type:        framework.TypeBool,
				Description: "Verify that SEC.SEPT_VE_DISABLE attribute is set",
				Default:     true,

				DisplayAttrs: &framework.DisplayAttributes{
					Name:        "Check SEC.SEPT_VE_DISABLE",
					Description: "Verify that EPT violation conversion to #VE on TD access of PENDING pages is disabled",
				},
			},
		},

		DisplayAttrs: &framework.DisplayAttributes{
			OperationPrefix: opPrefixTDX,
			OperationSuffix: "tdx",
			Action:          "Create",
			ItemType:        "TDX",
		},

		Operations: map[logical.Operation]framework.OperationHandler{
			logical.CreateOperation: &framework.PathOperation{
				Callback: b.pathTDXUpsert,
			},

			logical.UpdateOperation: &framework.PathOperation{
				Callback: b.pathTDXUpsert,
			},

			logical.ReadOperation: &framework.PathOperation{
				Callback: b.pathTDXRead,
			},

			logical.DeleteOperation: &framework.PathOperation{
				Callback: b.pathTDXDelete,
			},
		},
	}

	tokenutil.AddTokenFields(path.Fields)

	return path
}

func pathTDXList(b *backend) *framework.Path {
	return &framework.Path{
		Pattern:         "tdx/?",
		HelpSynopsis:    helpTDXSynopsys,
		HelpDescription: helpTDXDescription,

		Operations: map[logical.Operation]framework.OperationHandler{
			logical.ListOperation: &framework.PathOperation{
				Callback: b.pathTDXList,
			},
		},

		DisplayAttrs: &framework.DisplayAttributes{
			OperationPrefix: opPrefixTDX,
			OperationSuffix: "tdx",
			ItemType:        "TDX",
			Navigation:      true,
		},
	}
}

func (b *backend) pathTDXExists(
	ctx context.Context,
	req *logical.Request,
	data *framework.FieldData,
) (bool, error) {
	td, err := b.loadTDX(ctx, req.Storage, data.Get("name").(string))
	if err != nil {
		return false, err
	}
	return td != nil, nil
}

func (b *backend) pathTDXUpsert(
	ctx context.Context,
	req *logical.Request,
	data *framework.FieldData,
) (*logical.Response, error) {
	name, err := b.getName(ctx, data)
	if err != nil {
		return logical.ErrorResponse(err.Error()), err
	}

	td, isNew, err := b.upsertTDX(ctx, req, data, name)
	if err != nil {
		return logical.ErrorResponse(err.Error()), err
	}

	if err := b.parseTokenFields(ctx, req, data, td); err != nil {
		return logical.ErrorResponse(err.Error()), err
	}

	if td.TOTPSecret == "" {
		if err := b.generateTOTPSecret(ctx, td); err != nil {
			return logical.ErrorResponse(err.Error()), err
		}
	}

	if err := b.pushTDX(ctx, req, td); err != nil {
		return logical.ErrorResponse(err.Error()), err
	}

	_data, err := b.encodeTD(ctx, td)
	if err != nil {
		return logical.ErrorResponse(err.Error()), err
	}
	if isNew { // show totp secret only when creating
		_data["totp_secret"] = td.TOTPSecret
	}
	return &logical.Response{
		Data: _data,
	}, nil
}

func (b *backend) pathTDXRead(
	ctx context.Context,
	req *logical.Request,
	data *framework.FieldData,
) (*logical.Response, error) {
	name, err := b.getName(ctx, data)
	if err != nil {
		return logical.ErrorResponse(err.Error()), err
	}

	td, err := b.fetchTDX(ctx, req, name)
	if err != nil {
		return logical.ErrorResponse(err.Error()), err
	}

	_data, err := b.encodeTD(ctx, td)
	if err != nil {
		return logical.ErrorResponse(err.Error()), err
	}
	return &logical.Response{
		Data: _data,
	}, nil
}

func (b *backend) pathTDXDelete(
	ctx context.Context,
	req *logical.Request,
	data *framework.FieldData,
) (*logical.Response, error) {
	l := b.Logger()

	name := data.Get("name").(string)

	l.Debug("deleting domain",
		"attestation_type", "tdx",
		"domain", name,
	)

	if err := b.deleteTDX(ctx, req.Storage, name); err != nil {
		msg := "failed to delete domain"
		l.Error(msg,
			"attestation_type", "tdx",
			"domain", name,
			"error", err,
		)
		return logical.ErrorResponse("%s: %s", msg, err), fmt.Errorf("%s: %w", msg, err)
	}

	return nil, nil
}

func (b *backend) pathTDXList(
	ctx context.Context,
	req *logical.Request,
	data *framework.FieldData,
) (*logical.Response, error) {
	l := b.Logger()

	tds, err := b.listTDX(ctx, req.Storage)

	if err != nil {
		msg := "failed to list domains"
		l.Error(msg,
			"attestation_type", "tdx",
			"error", err,
		)
		return logical.ErrorResponse("%s: %s", msg, err), fmt.Errorf("%s: %w", msg, err)
	}

	return logical.ListResponse(tds), nil
}
