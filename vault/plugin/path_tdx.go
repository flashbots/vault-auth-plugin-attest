package plugin

import (
	"context"
	"time"

	"github.com/flashbots/vault-auth-plugin-attest/globals"
	"github.com/flashbots/vault-auth-plugin-attest/types"
	"github.com/hashicorp/vault/sdk/framework"
	"github.com/hashicorp/vault/sdk/helper/tokenutil"
	"github.com/hashicorp/vault/sdk/logical"
	"github.com/mitchellh/mapstructure"
	"github.com/pquerna/otp/totp"
)

const helpTDXSynopsys = `
Manage TDX trusted domains that are allowed to authenticate.
`

const helpTDXDescription = `
This endpoint allows you to create, read, update, and delete TDX trusted
domains that are allowed to authenticate.
`

const (
	opPrefixTDX = "tdx-op-prefix"
)

func pathTDX(b *backend) *framework.Path {
	path := &framework.Path{
		Pattern:         "tdx/" + framework.GenericNameRegex("name"),
		HelpSynopsis:    helpTDXSynopsys,
		HelpDescription: helpTDXDescription,

		ExistenceCheck: b.pathTDXExists,

		Fields: map[string]*framework.FieldSchema{
			"name": {
				Type:        framework.TypeString,
				Description: "TDX trusted domain name",
			},

			// TOTP

			"totp_secret": {
				Type:        framework.TypeString,
				Description: "Secret used to generate TOTP codes",

				DisplayAttrs: &framework.DisplayAttributes{
					Name:        "TOTP secret",
					Description: "Secret used to generate TOTP codes (can only be set, and is never shown in the UI)",
					Sensitive:   true,
				},
			},

			// MROWNER

			"tdx_mr_owner": {
				Type:        framework.TypeString,
				Description: "Expected software-defined ID for the TD's owner",

				DisplayAttrs: &framework.DisplayAttributes{
					Name:        "MROWNER",
					Description: "Software-defined ID for the TD's owner (base64-encoded 48 byte array)",
				},
			},

			// MROWNERCONFIG

			"tdx_mr_owner_config": {
				Type:        framework.TypeString,
				Description: "Expected software-defined ID for owner-defined configuration of the TD",

				DisplayAttrs: &framework.DisplayAttributes{
					Name:        "MROWNERCONFIG",
					Description: "Software-defined ID for owner-defined configuration of the TD, e.g., specific to the workload rather than the runtime or OS (base64-encoded 48 byte array)",
				},
			},

			// MRCONFIGID

			"tdx_mr_config_id": {
				Type:        framework.TypeString,
				Description: "Expected software-defined ID for non-owner-defined configuration of the TD",

				DisplayAttrs: &framework.DisplayAttributes{
					Name:        "MRCONFIGID",
					Description: "Software-defined ID for non-owner-defined configuration of the TD, e.g., runtime or OS configuration (base64-encoded 48 byte array)",
				},
			},

			// MRTD

			"tdx_mr_td": {
				Type:        framework.TypeString,
				Description: "Expected measurement of initial contents of the TD",

				DisplayAttrs: &framework.DisplayAttributes{
					Name:        "MRTD",
					Description: "Measurement of the initial contents of the TD (base64-encoded SHA384)",
				},
			},

			// RTMR0

			"tdx_rtmr0": {
				Type:        framework.TypeString,
				Description: "Expected runtime-extendable measurement register #0",

				DisplayAttrs: &framework.DisplayAttributes{
					Name:        "RTMR[0]",
					Description: "Runtime extendable measurement register #0 (base64-encoded SHA384). By convention, RTMR[0] is updated by the TD virtual firmware/BIOS",
				},
			},

			// RTMR1

			"tdx_rtmr1": {
				Type:        framework.TypeString,
				Description: "Expected runtime-extendable measurement register #1",

				DisplayAttrs: &framework.DisplayAttributes{
					Name:        "RTMR[1]",
					Description: "Runtime extendable measurement register #1 (base64-encoded SHA384). By convention, RTMR[1] is updated by the TD virtual firmware/BIOS",
				},
			},

			// RTMR2

			"tdx_rtmr2": {
				Type:        framework.TypeString,
				Description: "Expected runtime-extendable measurement register #2",

				DisplayAttrs: &framework.DisplayAttributes{
					Name:        "RTMR[2]",
					Description: "Runtime extendable measurement register #2 (base64-encoded SHA384). By convention, RTMR[2] measurements are generated by the OS",
				},
			},

			// RTMR3

			"tdx_rtmr3": {
				Type:        framework.TypeString,
				Description: "Expected runtime-extendable measurement register #3",

				DisplayAttrs: &framework.DisplayAttributes{
					Name:        "RTMR[3]",
					Description: "Runtime extendable measurement register #3 (base64-encoded SHA384). By convention, RTMR[3] measurements are generated by runtime code",
				},
			},

			// TDATTIBUTES.TUD

			"tdx_check_debug": {
				Type:        framework.TypeBool,
				Description: "Verify that TUD.DEBUG attribute is unset",
				Default:     true,

				DisplayAttrs: &framework.DisplayAttributes{
					Name:        "Check TDATTIBUTES.TUD",
					Description: "Verify that TD Under Debug flag is set to zero (if it's not zero then TD should not be trusted and thus should not be provisioned with production secrets)",
				},
			},

			// SEC.SEPT_VE_DISABLE

			"tdx_check_sept_ve_disable": {
				Type:        framework.TypeBool,
				Description: "Verify that SEC.SEPT_VE_DISABLE attribute is set",
				Default:     true,

				DisplayAttrs: &framework.DisplayAttributes{
					Name:        "Check SEC.SEPT_VE_DISABLE",
					Description: "Verify that EPT violation conversion to #VE on TD access of PENDING pages is disabled",
				},
			},
		},

		DisplayAttrs: &framework.DisplayAttributes{
			OperationPrefix: opPrefixTDX,
			OperationSuffix: "tdx",
			Action:          "Create",
			ItemType:        "TDX",
		},

		Operations: map[logical.Operation]framework.OperationHandler{
			logical.CreateOperation: &framework.PathOperation{
				Callback: b.pathTDXUpsert,
			},

			logical.UpdateOperation: &framework.PathOperation{
				Callback: b.pathTDXUpsert,
			},

			logical.ReadOperation: &framework.PathOperation{
				Callback: b.pathTDXRead,
			},

			logical.DeleteOperation: &framework.PathOperation{
				Callback: b.pathTDXDelete,
			},
		},
	}

	tokenutil.AddTokenFields(path.Fields)

	return path
}

func pathTDXList(b *backend) *framework.Path {
	return &framework.Path{
		Pattern:         "tdx/?",
		HelpSynopsis:    helpTDXSynopsys,
		HelpDescription: helpTDXDescription,

		Operations: map[logical.Operation]framework.OperationHandler{
			logical.ListOperation: &framework.PathOperation{
				Callback: b.pathTDXList,
			},
		},

		DisplayAttrs: &framework.DisplayAttributes{
			OperationPrefix: opPrefixTDX,
			OperationSuffix: "tdx",
			ItemType:        "TDX",
			Navigation:      true,
		},
	}
}

func (b *backend) pathTDXExists(
	ctx context.Context,
	req *logical.Request,
	data *framework.FieldData,
) (bool, error) {
	tdx, err := b.loadTDX(ctx, req.Storage, data.Get("name").(string))
	if err != nil {
		return false, err
	}
	return tdx != nil, nil
}

func (b *backend) pathTDXUpsert(
	ctx context.Context,
	req *logical.Request,
	data *framework.FieldData,
) (*logical.Response, error) {
	l := b.Logger()

	var (
		name  string
		tdx   *types.TDX
		err   error
		isNew bool
	)

	{ // fetch from the storage
		name = data.Get("name").(string)
		if name == "" {
			return b.invalidRequest("tdx domain name is required")
		}

		tdx, err = b.loadTDX(ctx, req.Storage, name)
		if err != nil {
			return b.loggedError("failed to load tdx domain from storage",
				"domain", name,
				"error", err,
			)
		}

		mrOwner, errs := extractByte48(data, "tdx_mr_owner", nil)
		mrOwnerConfig, errs := extractByte48(data, "tdx_mr_owner_config", errs)
		mrConfigID, errs := extractByte48(data, "tdx_mr_config_id", errs)
		mrTD, errs := extractByte48(data, "tdx_mr_td", errs)
		rtmr0, errs := extractByte48(data, "tdx_rtmr0", errs)
		rtmr1, errs := extractByte48(data, "tdx_rtmr1", errs)
		rtmr2, errs := extractByte48(data, "tdx_rtmr2", errs)
		rtmr3, errs := extractByte48(data, "tdx_rtmr3", errs)

		if err := errs.ErrorOrNil(); err != nil {
			return b.invalidRequest("failed to create new tdx entry: %s", err)
		}

		if tdx != nil {
			l.Debug("updating tdx trusted domain", "name", name)

			if totpSecret, ok := data.GetOk("totp_secret"); ok {
				tdx.TOTPSecret = totpSecret.(string)
			}
			if checkDebug, ok := data.GetOk("tdx_check_debug"); ok {
				tdx.CheckDebug = checkDebug.(bool)
			}
			if checkSeptVeDisable, ok := data.GetOk("tdx_check_sept_ve_disable"); ok {
				tdx.CheckSeptVeDisable = checkSeptVeDisable.(bool)
			}

			if mrOwner != nil {
				tdx.MrOwner = mrOwner
			}
			if mrOwnerConfig != nil {
				tdx.MrOwnerConfig = mrOwnerConfig
			}
			if mrConfigID != nil {
				tdx.MrConfigID = mrConfigID
			}
			if mrTD != nil {
				tdx.MrTD = mrTD
			}
			if rtmr0 != nil {
				tdx.RTMR0 = rtmr0
			}
			if rtmr1 != nil {
				tdx.RTMR1 = rtmr1
			}
			if rtmr2 != nil {
				tdx.RTMR2 = rtmr2
			}
			if rtmr3 != nil {
				tdx.RTMR3 = rtmr3
			}
		} else {
			l.Debug("creating tdx domain", "name", name)

			isNew = true

			tdx = &types.TDX{
				TOTPSecret:         data.Get("totp_secret").(string),
				CheckDebug:         data.Get("tdx_check_debug").(bool),
				CheckSeptVeDisable: data.Get("tdx_check_sept_ve_disable").(bool),

				MrOwner:       mrOwner,
				MrOwnerConfig: mrOwnerConfig,
				MrConfigID:    mrConfigID,
				MrTD:          mrTD,
				RTMR0:         rtmr0,
				RTMR1:         rtmr1,
				RTMR2:         rtmr2,
				RTMR3:         rtmr3,
			}
		}
	}

	{ // parse token parameters
		if err := tdx.ParseTokenFields(req, data); err != nil {
			return b.invalidRequest("failed to create new tdx entry: %s", err)
		}
	}

	{ // generate totp secret if it's empty
		if tdx.TOTPSecret == "" {
			totpKey, err := totp.Generate(totp.GenerateOpts{
				AccountName: name,
				Algorithm:   globals.TOTPAlgorithm,
				Digits:      globals.TOTPDigits,
				Issuer:      "vault",
				Period:      uint(globals.TOTPPeriod / time.Second),
				Rand:        b.Rand(),
			})
			if err != nil {
				return b.loggedError("failed to generate totp secret",
					"domain", name,
					"error", err,
				)
			}
			tdx.TOTPSecret = totpKey.Secret()
		}
	}

	{ // push to the storage
		if err := b.saveTDX(ctx, req.Storage, name, tdx); err != nil {
			return b.loggedError("failed to save tdx domain into storage",
				"domain", name,
				"error", err,
			)
		}
	}

	{ // return result
		data := map[string]interface{}{}
		if err := mapstructure.Decode(tdx, &data); err != nil {
			return b.loggedError("failed to encode the result",
				"domain", name,
				"error", err,
			)
		}
		tdx.PopulateTokenData(data)
		if isNew { // show totp secret only when creating
			data["totp_secret"] = tdx.TOTPSecret
		}

		return &logical.Response{
			Data: data,
		}, nil
	}
}

func (b *backend) pathTDXRead(
	ctx context.Context,
	req *logical.Request,
	data *framework.FieldData,
) (*logical.Response, error) {
	var (
		name string
		tdx  *types.TDX
		err  error
	)

	{ // fetch from the storage
		name = data.Get("name").(string)
		if name == "" {
			return b.invalidRequest("tdx domain name is required")
		}

		tdx, err = b.loadTDX(ctx, req.Storage, name)
		if err != nil {
			return b.loggedError("failed to load tdx domain from storage",
				"domain", name,
				"error", err,
			)
		}

		if tdx == nil {
			return nil, nil
		}
	}

	{ // return result
		data := map[string]interface{}{}
		if err := mapstructure.Decode(tdx, &data); err != nil {
			return b.loggedError("failed to encode the result",
				"domain", name,
				"error", err,
			)
		}
		tdx.PopulateTokenData(data)

		return &logical.Response{
			Data: data,
		}, nil
	}
}

func (b *backend) pathTDXDelete(
	ctx context.Context,
	req *logical.Request,
	data *framework.FieldData,
) (*logical.Response, error) {
	l := b.Logger()

	name := data.Get("name").(string)

	l.Debug("deleting tdx domain", "name", name)

	if err := b.deleteTDX(ctx, req.Storage, name); err != nil {
		return b.loggedError("failed to delete tdx domain",
			"domain", name,
			"error", err,
		)
	}

	return nil, nil
}

func (b *backend) pathTDXList(
	ctx context.Context,
	req *logical.Request,
	data *framework.FieldData,
) (*logical.Response, error) {
	tdxs, err := b.listTDX(ctx, req.Storage)

	if err != nil {
		return b.loggedError("failed to list tdx domains",
			"error", err,
		)
	}

	return logical.ListResponse(tdxs), nil
}
